<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Header Analyzer - SOC Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, #f44336 0%, #e91e63 100%);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .input-section {
            background: rgba(255,255,255,0.05);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .input-label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .header-input {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s;
        }

        .header-input:focus {
            outline: none;
            border-color: #f44336;
            background: rgba(0,0,0,0.4);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .btn-analyze {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }

        .btn-clear {
            background: linear-gradient(135deg, #757575 0%, #616161 100%);
            box-shadow: 0 4px 15px rgba(117, 117, 117, 0.3);
        }

        .btn-example {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        .results-container {
            display: none;
        }

        .risk-assessment {
            background: rgba(255,255,255,0.05);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .risk-score {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .risk-meter {
            width: 200px;
            height: 200px;
            position: relative;
            margin: 0 auto;
        }

        .risk-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                from 180deg,
                #4CAF50 0deg,
                #8BC34A 72deg,
                #FFEB3B 144deg,
                #FF9800 216deg,
                #f44336 288deg,
                #f44336 360deg
            );
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }

        .risk-inner {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .risk-value {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .risk-label {
            font-size: 1.2em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .risk-low { color: #4CAF50; }
        .risk-medium { color: #FFEB3B; }
        .risk-high { color: #FF9800; }
        .risk-critical { color: #f44336; }

        .alert-box {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.5s;
        }

        .alert-success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
        }

        .alert-warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #FFC107;
        }

        .alert-danger {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
        }

        .alert-info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196F3;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .analysis-card {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }

        .analysis-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .card-icon {
            font-size: 1.5em;
        }

        .card-title {
            font-size: 1.2em;
            font-weight: 600;
        }

        .card-content {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .card-content > div {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .card-content .label {
            color: #64B5F6;
            font-weight: bold;
            min-width: 110px;
            display: inline-block;
        }

        .card-content .value {
            color: #fff;
            word-break: break-word;
            display: inline-block;
            max-width: calc(100% - 120px);
            vertical-align: top;
        }

        .path-visualization {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            overflow-x: auto;
        }

        .path-node {
            display: inline-block;
            padding: 8px 15px;
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            border-radius: 20px;
            margin: 5px;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(33, 150, 243, 0.3);
            animation: fadeIn 0.5s;
        }

        .path-arrow {
            display: inline-block;
            margin: 0 10px;
            color: #FFC107;
            font-weight: bold;
        }

        .spf-pass { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important; }
        .spf-fail { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%) !important; }
        .spf-softfail { background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%) !important; }
        .spf-neutral { background: linear-gradient(135deg, #9E9E9E 0%, #757575 100%) !important; }
        .spf-none { background: linear-gradient(135deg, #607D8B 0%, #455A64 100%) !important; }

        .dkim-pass { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important; }
        .dkim-fail { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%) !important; }

        .dmarc-pass { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important; }
        .dmarc-fail { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%) !important; }

        .timeline {
            background: rgba(255,255,255,0.05);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
            padding-left: 40px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #2196F3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }

        .timeline-item::after {
            content: '';
            position: absolute;
            left: 14px;
            top: 50%;
            width: 2px;
            height: calc(100% + 20px);
            background: rgba(255,255,255,0.1);
        }

        .timeline-item:last-child::after {
            display: none;
        }

        .timeline-content {
            flex: 1;
        }

        .timeline-server {
            font-weight: bold;
            color: #64B5F6;
        }

        .timeline-date {
            font-size: 0.9em;
            color: #aaa;
        }

        .raw-headers {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .export-section {
            margin-top: 30px;
            text-align: center;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255,255,255,0.05);
            border: none;
            color: #aaa;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 10px 10px 0 0;
        }

        .tab.active {
            background: rgba(33, 150, 243, 0.2);
            color: #fff;
            border-bottom: 2px solid #2196F3;
        }

        .tab:hover {
            background: rgba(255,255,255,0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
            margin: 2px;
            font-weight: bold;
        }

        .indicator-suspicious {
            background: rgba(244, 67, 54, 0.3);
            color: #ff6b6b;
        }

        .indicator-warning {
            background: rgba(255, 193, 7, 0.3);
            color: #FFC107;
        }

        .indicator-safe {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        .indicator-internal {
            background: rgba(33, 150, 243, 0.3);
            color: #2196F3;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.1);
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .email-type-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .email-internal {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
        }

        .email-external {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📧 Email Header Analyzer</h1>
            <p>Профессиональный инструмент для анализа заголовков email и выявления фишинга</p>
        </div>

        <div class="input-section">
            <label class="input-label" for="headerInput">
                Вставьте полные заголовки email (скопируйте из "View Original" или "Show Original"):
            </label>
            <textarea 
                id="headerInput" 
                class="header-input" 
                placeholder="Delivered-To: user@example.com&#10;Received: by 2002:a05:6512:3b8f:b0:4f5:c2fc:748b with SMTP id...&#10;Return-Path: <sender@domain.com>&#10;..."
            ></textarea>
            <div class="button-group">
                <button class="btn btn-analyze" onclick="analyzeHeaders()">
                    🔍 Анализировать
                </button>
                <button class="btn btn-example" onclick="loadExample()">
                    📋 Загрузить пример
                </button>
                <button class="btn btn-clear" onclick="clearAll()">
                    🗑️ Очистить
                </button>
            </div>
        </div>

        <div class="loading">
            <div class="spinner"></div>
            <p>Анализируем заголовки...</p>
        </div>

        <div class="results-container" id="results">
            <!-- Risk Assessment -->
            <div class="risk-assessment">
                <h2 style="text-align: center; margin-bottom: 20px;">🎯 Оценка риска</h2>
                <div style="text-align: center;">
                    <span class="email-type-badge" id="emailTypeBadge"></span>
                </div>
                <div class="risk-score">
                    <div class="risk-meter">
                        <div class="risk-circle">
                            <div class="risk-inner">
                                <div class="risk-value" id="riskScore">0</div>
                                <div class="risk-label" id="riskLabel">Анализ</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="alertsContainer"></div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab('summary')">📊 Сводка</button>
                <button class="tab" onclick="switchTab('path')">🛣️ Путь доставки</button>
                <button class="tab" onclick="switchTab('authentication')">🔐 Аутентификация</button>
                <button class="tab" onclick="switchTab('headers')">📄 Заголовки</button>
                <button class="tab" onclick="switchTab('raw')">💻 Raw данные</button>
            </div>

            <!-- Summary Tab -->
            <div class="tab-content active" id="summary-tab">
                <div class="analysis-grid">
                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">👤</span>
                            <span class="card-title">Отправитель</span>
                        </div>
                        <div class="card-content">
                            <div><span class="label">From:</span> <span class="value" id="fromAddress">-</span></div>
                            <div><span class="label">Reply-To:</span> <span class="value" id="replyTo">-</span></div>
                            <div><span class="label">Return-Path:</span> <span class="value" id="returnPath">-</span></div>
                            <div id="senderIndicators"></div>
                        </div>
                    </div>

                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">📨</span>
                            <span class="card-title">Получатель</span>
                        </div>
                        <div class="card-content">
                            <div><span class="label">To:</span> <span class="value" id="toAddress">-</span></div>
                            <div><span class="label">Delivered-To:</span> <span class="value" id="deliveredTo">-</span></div>
                            <div><span class="label">CC:</span> <span class="value" id="ccAddress">-</span></div>
                            <div><span class="label">BCC:</span> <span class="value" id="bccAddress">-</span></div>
                        </div>
                    </div>

                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">📋</span>
                            <span class="card-title">Метаданные</span>
                        </div>
                        <div class="card-content">
                            <div><span class="label">Subject:</span> <span class="value" id="subject">-</span></div>
                            <div><span class="label">Message-ID:</span> <span class="value" id="messageId">-</span></div>
                            <div><span class="label">Date:</span> <span class="value" id="date">-</span></div>
                            <div><span class="label">X-Mailer:</span> <span class="value" id="xMailer">-</span></div>
                        </div>
                    </div>

                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">🌐</span>
                            <span class="card-title">Источник</span>
                        </div>
                        <div class="card-content">
                            <div><span class="label">Originating IP:</span> <span class="value" id="originIP">-</span></div>
                            <div><span class="label">X-Originating-IP:</span> <span class="value" id="xOriginatingIP">-</span></div>
                            <div><span class="label">Client IP:</span> <span class="value" id="clientIP">-</span></div>
                            <div id="ipIndicators"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Path Tab -->
            <div class="tab-content" id="path-tab">
                <div class="timeline">
                    <h3 style="margin-bottom: 20px;">📍 Путь следования email</h3>
                    <div id="pathTimeline"></div>
                </div>
                <div class="path-visualization" id="pathVisualization"></div>
            </div>

            <!-- Authentication Tab -->
            <div class="tab-content" id="authentication-tab">
                <div class="analysis-grid">
                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">🔒</span>
                            <span class="card-title">SPF (Sender Policy Framework)</span>
                        </div>
                        <div class="card-content" id="spfResults">
                            <div>Анализ SPF...</div>
                        </div>
                    </div>

                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">🔑</span>
                            <span class="card-title">DKIM (DomainKeys Identified Mail)</span>
                        </div>
                        <div class="card-content" id="dkimResults">
                            <div>Анализ DKIM...</div>
                        </div>
                    </div>

                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">🛡️</span>
                            <span class="card-title">DMARC</span>
                        </div>
                        <div class="card-content" id="dmarcResults">
                            <div>Анализ DMARC...</div>
                        </div>
                    </div>

                    <div class="analysis-card">
                        <div class="card-header">
                            <span class="card-icon">🔐</span>
                            <span class="card-title">Шифрование</span>
                        </div>
                        <div class="card-content" id="encryptionResults">
                            <div>Анализ шифрования...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Headers Tab -->
            <div class="tab-content" id="headers-tab">
                <div class="analysis-card">
                    <div class="card-header">
                        <span class="card-icon">📄</span>
                        <span class="card-title">Все заголовки</span>
                    </div>
                    <div class="card-content" id="allHeaders"></div>
                </div>
            </div>

            <!-- Raw Tab -->
            <div class="tab-content" id="raw-tab">
                <div class="raw-headers" id="rawHeaders"></div>
            </div>

            <!-- Export Section -->
            <div class="export-section">
                <button class="btn" onclick="exportAnalysis()">
                    💾 Экспортировать отчет
                </button>
            </div>
        </div>
    </div>

    <script>
        let currentAnalysis = null;

        // Функция декодирования base64 в байты
        function base64ToBytes(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        // Функция конвертации windows-1251 в UTF-8
        function windows1251ToUTF8(bytes) {
            // Таблица маппинга windows-1251 в Unicode для байтов 0x80-0xFF
            const cp1251 = [
                0x0402, 0x0403, 0x201A, 0x0453, 0x201E, 0x2026, 0x2020, 0x2021, // 80-87
                0x20AC, 0x2030, 0x0409, 0x2039, 0x040A, 0x040C, 0x040B, 0x040F, // 88-8F
                0x0452, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, // 90-97
                0x0098, 0x2122, 0x0459, 0x203A, 0x045A, 0x045C, 0x045B, 0x045F, // 98-9F
                0x00A0, 0x040E, 0x045E, 0x0408, 0x00A4, 0x0490, 0x00A6, 0x00A7, // A0-A7
                0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407, // A8-AF
                0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7, // B0-B7
                0x0451, 0x2116, 0x0454, 0x00BB, 0x0458, 0x0405, 0x0455, 0x0457, // B8-BF
                0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, // C0-C7
                0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F, // C8-CF
                0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, // D0-D7
                0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F, // D8-DF
                0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, // E0-E7
                0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, // E8-EF
                0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, // F0-F7
                0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F  // F8-FF
            ];

            let result = '';
            
            // Если это строка, конвертируем в байты
            if (typeof bytes === 'string') {
                const arr = new Uint8Array(bytes.length);
                for (let i = 0; i < bytes.length; i++) {
                    arr[i] = bytes.charCodeAt(i);
                }
                bytes = arr;
            }
            
            // Декодируем каждый байт
            for (let i = 0; i < bytes.length; i++) {
                const byte = bytes[i];
                if (byte < 0x80) {
                    // ASCII символы
                    result += String.fromCharCode(byte);
                } else {
                    // Используем таблицу маппинга для байтов 0x80-0xFF
                    const unicode = cp1251[byte - 0x80];
                    result += String.fromCharCode(unicode);
                }
            }
            
            return result;
        }

        // Декодирование MIME-encoded заголовков
        function decodeMimeHeader(encoded) {
            if (!encoded || !encoded.includes('=?')) {
                return encoded;
            }

            try {
                const regex = /=\?([^?]+)\?([BQ])\?([^?]+)\?=/gi;
                return encoded.replace(regex, function(match, charset, encoding, text) {
                    charset = charset.toLowerCase();
                    
                    if (encoding.toUpperCase() === 'B') {
                        try {
                            // Декодируем Base64 в байты
                            const bytes = base64ToBytes(text.replace(/\s/g, ''));
                            
                            // Если кодировка windows-1251 или cp1251, конвертируем
                            if (charset.includes('1251') || charset === 'cp1251' || charset === 'windows-1251') {
                                return windows1251ToUTF8(bytes);
                            } else if (charset.includes('utf-8') || charset.includes('utf8')) {
                                // UTF-8 декодирование с помощью TextDecoder если доступен
                                if (typeof TextDecoder !== 'undefined') {
                                    try {
                                        return new TextDecoder('utf-8').decode(bytes);
                                    } catch (e) {
                                        // Fallback на ручное декодирование
                                        let result = '';
                                        for (let i = 0; i < bytes.length; i++) {
                                            result += String.fromCharCode(bytes[i]);
                                        }
                                        return result;
                                    }
                                } else {
                                    // Fallback если TextDecoder недоступен
                                    let result = '';
                                    for (let i = 0; i < bytes.length; i++) {
                                        result += String.fromCharCode(bytes[i]);
                                    }
                                    return result;
                                }
                            } else {
                                // Для остальных кодировок пытаемся декодировать как Latin-1
                                let result = '';
                                for (let i = 0; i < bytes.length; i++) {
                                    result += String.fromCharCode(bytes[i]);
                                }
                                return result;
                            }
                        } catch (e) {
                            console.error('Error decoding Base64:', e);
                            return text;
                        }
                    } else if (encoding.toUpperCase() === 'Q') {
                        // Quoted-printable декодирование
                        let decoded = text.replace(/_/g, ' ');
                        
                        // Создаем массив байтов из quoted-printable
                        const bytes = [];
                        let i = 0;
                        while (i < decoded.length) {
                            if (decoded[i] === '=' && i + 2 < decoded.length) {
                                const hex = decoded.substr(i + 1, 2);
                                if (/^[0-9A-Fa-f]{2}$/.test(hex)) {
                                    bytes.push(parseInt(hex, 16));
                                    i += 3;
                                } else {
                                    bytes.push(decoded.charCodeAt(i));
                                    i++;
                                }
                            } else {
                                bytes.push(decoded.charCodeAt(i));
                                i++;
                            }
                        }
                        
                        // Конвертируем байты в строку в зависимости от кодировки
                        if (charset.includes('1251') || charset === 'cp1251' || charset === 'windows-1251') {
                            return windows1251ToUTF8(new Uint8Array(bytes));
                        } else {
                            // Для других кодировок
                            let result = '';
                            for (let j = 0; j < bytes.length; j++) {
                                result += String.fromCharCode(bytes[j]);
                            }
                            return result;
                        }
                    }
                    return text;
                });
            } catch (e) {
                console.error('Error decoding MIME header:', e);
                return encoded;
            }
        }

        // Извлечение и форматирование email адреса с именем
        function formatEmailAddress(header) {
            if (!header || header === '-') return '-';
            
            // Сначала декодируем MIME
            const decoded = decodeMimeHeader(header);
            
            // Извлекаем имя и email
            const emailMatch = decoded.match(/([^<]*)<([^>]+)>/);
            if (emailMatch) {
                const name = emailMatch[1].trim();
                const email = emailMatch[2].trim();
                if (name) {
                    return `${name} <${email}>`;
                }
                return email;
            }
            
            // Если это просто email без имени
            const simpleEmail = decoded.match(/[\w\.-]+@[\w\.-]+/);
            if (simpleEmail) {
                return simpleEmail[0];
            }
            
            return decoded;
        }

        // Улучшенный парсер заголовков
        function parseHeaders(headerText) {
            const lines = headerText.split(/\r?\n/);
            const headers = {};
            let currentHeader = '';
            let currentValue = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Проверяем, начинается ли строка с заголовка
                if (line.match(/^[A-Za-z0-9\-]+:\s/)) {
                    // Сохраняем предыдущий заголовок, если он есть
                    if (currentHeader) {
                        if (!headers[currentHeader]) {
                            headers[currentHeader] = [];
                        }
                        headers[currentHeader].push(currentValue.trim());
                    }
                    
                    // Парсим новый заголовок
                    const colonIndex = line.indexOf(':');
                    currentHeader = line.substring(0, colonIndex).trim();
                    currentValue = line.substring(colonIndex + 1).trim();
                } else if (line.match(/^\s+/) && currentHeader) {
                    // Это продолжение предыдущего заголовка
                    currentValue += ' ' + line.trim();
                } else if (line === '' && currentHeader) {
                    // Пустая строка может означать конец заголовков
                    if (currentHeader) {
                        if (!headers[currentHeader]) {
                            headers[currentHeader] = [];
                        }
                        headers[currentHeader].push(currentValue.trim());
                        currentHeader = '';
                        currentValue = '';
                    }
                }
            }

            // Сохраняем последний заголовок
            if (currentHeader) {
                if (!headers[currentHeader]) {
                    headers[currentHeader] = [];
                }
                headers[currentHeader].push(currentValue.trim());
            }

            return headers;
        }

        // Улучшенное извлечение IP-адресов
        function extractIPs(text) {
            if (!text) return [];
            const ipRegex = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/g;
            const matches = text.match(ipRegex);
            return matches || [];
        }

        // Извлечение домена из email адреса
        function extractDomain(email) {
            const match = email.match(/@([^>\s]+)/);
            return match ? match[1] : null;
        }

        // Анализ Received заголовков
        function analyzeReceivedHeaders(headers) {
            const received = headers['Received'] || [];
            const path = [];
            
            received.forEach((header, index) => {
                const fromMatch = header.match(/from\s+([^\s\(]+)(?:\s+\(([^)]+)\))?/i);
                const byMatch = header.match(/by\s+([^\s\(]+)(?:\s+\(([^)]+)\))?/i);
                const withMatch = header.match(/with\s+([^\s;]+)/i);
                const idMatch = header.match(/id\s+([^\s;]+)/i);
                const viaMatch = header.match(/via\s+([^\s;]+)/i);
                
                // Ищем дату в конце заголовка или после точки с запятой
                let dateMatch = header.match(/;\s*(.+)$/);
                if (!dateMatch) {
                    // Попробуем найти дату в другом формате
                    dateMatch = header.match(/\d{1,2}\s+\w{3}\s+\d{4}\s+\d{1,2}:\d{2}:\d{2}/);
                }
                
                const ips = extractIPs(header);
                
                const hop = {
                    index: received.length - index,
                    from: fromMatch ? fromMatch[1] : 'unknown',
                    fromIP: fromMatch && fromMatch[2] ? fromMatch[2] : (ips[0] || null),
                    by: byMatch ? byMatch[1] : 'unknown',
                    byIP: byMatch && byMatch[2] ? byMatch[2] : (ips[1] || null),
                    with: withMatch ? withMatch[1] : 'unknown',
                    id: idMatch ? idMatch[1] : null,
                    via: viaMatch ? viaMatch[1] : null,
                    date: dateMatch ? (dateMatch[1] || dateMatch[0]) : 'unknown',
                    allIPs: ips,
                    raw: header
                };
                
                path.push(hop);
            });

            return path.reverse();
        }

        // Анализ SPF
        function analyzeSPF(headers) {
            const authResults = headers['Authentication-Results'] || [];
            const spfReceived = headers['Received-SPF'] || [];
            
            let spfResult = {
                status: 'none',
                details: 'SPF не проверялся',
                domain: '',
                ip: ''
            };

            // Проверяем Authentication-Results
            authResults.forEach(result => {
                const spfMatch = result.match(/spf=(\w+)(?:\s+\(([^)]+)\))?/i);
                if (spfMatch) {
                    spfResult.status = spfMatch[1].toLowerCase();
                    if (spfMatch[2]) {
                        spfResult.details = spfMatch[2];
                    }
                    const domainMatch = result.match(/smtp\.mailfrom=([^;\s]+)/i);
                    if (domainMatch) {
                        spfResult.domain = domainMatch[1];
                    }
                    const ipMatch = result.match(/client-ip=([^;\s]+)/i);
                    if (ipMatch) {
                        spfResult.ip = ipMatch[1];
                    }
                }
            });

            // Проверяем Received-SPF
            spfReceived.forEach(spf => {
                const statusMatch = spf.match(/^(\w+)/);
                if (statusMatch) {
                    spfResult.status = statusMatch[1].toLowerCase();
                }
                const detailsMatch = spf.match(/\(([^)]+)\)/);
                if (detailsMatch) {
                    spfResult.details = detailsMatch[1];
                }
                const ipMatch = spf.match(/client-ip=([^;\s]+)/i);
                if (ipMatch) {
                    spfResult.ip = ipMatch[1];
                }
            });

            return spfResult;
        }

        // Анализ DKIM
        function analyzeDKIM(headers) {
            const authResults = headers['Authentication-Results'] || [];
            const dkimSignature = headers['DKIM-Signature'] || [];
            
            let dkimResult = {
                status: 'none',
                domain: '',
                selector: '',
                signature: dkimSignature.length > 0,
                details: 'DKIM не проверялся'
            };

            authResults.forEach(result => {
                const dkimMatch = result.match(/dkim=(\w+)(?:\s+\(([^)]+)\))?/i);
                if (dkimMatch) {
                    dkimResult.status = dkimMatch[1].toLowerCase();
                    if (dkimMatch[2]) {
                        dkimResult.details = dkimMatch[2];
                    }
                    const domainMatch = result.match(/header\.[di]=([^;\s]+)/i);
                    if (domainMatch) {
                        dkimResult.domain = domainMatch[1];
                    }
                    const selectorMatch = result.match(/header\.s=([^;\s]+)/i);
                    if (selectorMatch) {
                        dkimResult.selector = selectorMatch[1];
                    }
                }
            });

            if (dkimSignature.length > 0) {
                const sig = dkimSignature[0];
                const selectorMatch = sig.match(/s=([^;]+)/i);
                const domainMatch = sig.match(/d=([^;]+)/i);
                
                if (selectorMatch && !dkimResult.selector) {
                    dkimResult.selector = selectorMatch[1].trim();
                }
                if (domainMatch && !dkimResult.domain) {
                    dkimResult.domain = domainMatch[1].trim();
                }
            }

            return dkimResult;
        }

        // Анализ DMARC
        function analyzeDMARC(headers) {
            const authResults = headers['Authentication-Results'] || [];
            
            let dmarcResult = {
                status: 'none',
                policy: '',
                domain: '',
                details: 'DMARC не проверялся'
            };

            authResults.forEach(result => {
                const dmarcMatch = result.match(/dmarc=(\w+)(?:\s+\(([^)]+)\))?/i);
                if (dmarcMatch) {
                    dmarcResult.status = dmarcMatch[1].toLowerCase();
                    if (dmarcMatch[2]) {
                        dmarcResult.details = dmarcMatch[2];
                    }
                    const policyMatch = result.match(/(?:action|p)=([^;\s]+)/i);
                    if (policyMatch) {
                        dmarcResult.policy = policyMatch[1];
                    }
                    const domainMatch = result.match(/header\.from=([^;\s]+)/i);
                    if (domainMatch) {
                        dmarcResult.domain = domainMatch[1];
                    }
                }
            });

            return dmarcResult;
        }

        // Определение типа письма (внутреннее/внешнее)
        function detectEmailType(headers, path) {
            // Проверяем, все ли IP-адреса приватные
            let hasExternalIP = false;
            let hasInternalDomain = false;
            
            path.forEach(hop => {
                hop.allIPs.forEach(ip => {
                    if (!isPrivateIP(ip) && !isLoopbackIP(ip)) {
                        hasExternalIP = true;
                    }
                });
            });

            // Проверяем домены
            const from = (headers['From'] || [''])[0];
            const to = (headers['To'] || [''])[0];
            
            if (from && to) {
                // Декодируем и извлекаем домены
                const decodedFrom = decodeMimeHeader(from);
                const decodedTo = decodeMimeHeader(to);
                const fromDomain = extractDomain(decodedFrom);
                const toDomain = extractDomain(decodedTo);
                
                if (fromDomain === toDomain) {
                    hasInternalDomain = true;
                }
            }

            // Проверяем наличие Exchange заголовков
            const hasExchange = headers['X-MS-Exchange-Organization-AuthAs'] || 
                               headers['X-MS-Exchange-Organization-AuthSource'] ||
                               headers['X-MS-Has-Attach'];

            if (!hasExternalIP && (hasInternalDomain || hasExchange)) {
                return 'internal';
            }
            
            return 'external';
        }

        // Расчет оценки риска
        function calculateRiskScore(analysis) {
            let score = 0;
            const alerts = [];

            // Определяем тип письма
            const emailType = analysis.emailType;

            if (emailType === 'internal') {
                // Для внутренней почты другие критерии
                
                // Проверяем подозрительные заголовки
                if (analysis.headers['X-Spam-Status']) {
                    const spamStatus = analysis.headers['X-Spam-Status'][0];
                    if (spamStatus.includes('Yes')) {
                        score += 30;
                        alerts.push({ type: 'warning', message: 'Письмо помечено как спам' });
                    }
                }

                // Проверяем антивирус
                const avHeaders = analysis.headers['X-KSE-Antivirus-Info'] || [];
                avHeaders.forEach(header => {
                    if (!header.includes('Clean')) {
                        score += 40;
                        alerts.push({ type: 'danger', message: 'Обнаружена угроза антивирусом' });
                    }
                });

                // Слишком много переходов для внутреннего письма
                if (analysis.path.length > 5) {
                    score += 10;
                    alerts.push({ type: 'info', message: 'Необычно длинный путь для внутреннего письма' });
                }

            } else {
                // Для внешней почты стандартные проверки
                
                // SPF проверка
                if (analysis.spf.status === 'pass') {
                    score += 0;
                } else if (analysis.spf.status === 'softfail') {
                    score += 20;
                    alerts.push({ type: 'warning', message: 'SPF soft fail - домен отправителя не полностью авторизован' });
                } else if (analysis.spf.status === 'fail') {
                    score += 35;
                    alerts.push({ type: 'danger', message: 'SPF fail - домен отправителя не авторизован!' });
                } else if (analysis.spf.status === 'none') {
                    score += 10;
                    alerts.push({ type: 'info', message: 'SPF не настроен для домена отправителя' });
                }

                // DKIM проверка
                if (analysis.dkim.status === 'pass') {
                    score += 0;
                } else if (analysis.dkim.status === 'fail') {
                    score += 30;
                    alerts.push({ type: 'danger', message: 'DKIM fail - подпись не прошла проверку!' });
                } else if (!analysis.dkim.signature && analysis.dkim.status === 'none') {
                    score += 15;
                    alerts.push({ type: 'warning', message: 'Отсутствует DKIM подпись' });
                }

                // DMARC проверка
                if (analysis.dmarc.status === 'pass') {
                    score += 0;
                } else if (analysis.dmarc.status === 'fail') {
                    score += 25;
                    alerts.push({ type: 'danger', message: 'DMARC fail - политика DMARC нарушена!' });
                } else if (analysis.dmarc.status === 'none') {
                    score += 5;
                    alerts.push({ type: 'info', message: 'DMARC не настроен' });
                }

                // From/Reply-To несоответствие
                if (analysis.from && analysis.from !== '-' && analysis.replyTo && analysis.replyTo !== '-') {
                    const fromDomain = extractDomain(analysis.from);
                    const replyDomain = extractDomain(analysis.replyTo);
                    if (fromDomain !== replyDomain) {
                        score += 20;
                        alerts.push({ type: 'warning', message: 'Домены From и Reply-To не совпадают' });
                    }
                }

                // Return-Path несоответствие
                if (analysis.from && analysis.from !== '-' && analysis.returnPath && analysis.returnPath !== '-') {
                    const fromDomain = extractDomain(analysis.from);
                    const returnDomain = extractDomain(analysis.returnPath);
                    if (fromDomain !== returnDomain) {
                        score += 15;
                        alerts.push({ type: 'warning', message: 'Домен Return-Path не совпадает с доменом From' });
                    }
                }
            }

            // Общие проверки для всех писем
            
            // Подозрительные слова в теме
            const suspiciousKeywords = [
                'urgent', 'verify', 'suspend', 'click here', 'act now', 
                'confirm', 'update', 'locked', 'security alert', 'suspicious activity',
                'verify your account', 'suspended', 'limited'
            ];
            const subjectLower = (analysis.subject || '').toLowerCase();
            const foundKeywords = suspiciousKeywords.filter(keyword => subjectLower.includes(keyword));
            if (foundKeywords.length > 0) {
                score += Math.min(foundKeywords.length * 5, 20);
                alerts.push({ type: 'info', message: `Тема содержит подозрительные слова: ${foundKeywords.join(', ')}` });
            }

            // Проверка на фишинговые признаки
            if (analysis.subject && analysis.subject.match(/[А-Яа-яЁё]/) && 
                analysis.from && !analysis.from.match(/\.ru|\.рф/i)) {
                score += 10;
                alerts.push({ type: 'info', message: 'Письмо на русском языке от нероссийского домена' });
            }

            // Слишком много переходов
            if (analysis.path.length > 10) {
                score += 15;
                alerts.push({ type: 'warning', message: `Слишком длинный путь доставки (${analysis.path.length} хопов)` });
            }

            // Ограничиваем максимальный балл
            score = Math.min(score, 100);

            return { score, alerts };
        }

        // Проверка приватного IP
        function isPrivateIP(ip) {
            if (!ip) return false;
            const parts = ip.split('.');
            if (parts.length !== 4) return false;
            
            const first = parseInt(parts[0]);
            const second = parseInt(parts[1]);
            
            return (first === 10) ||
                   (first === 172 && second >= 16 && second <= 31) ||
                   (first === 192 && second === 168);
        }

        // Проверка loopback IP
        function isLoopbackIP(ip) {
            if (!ip) return false;
            return ip.startsWith('127.') || ip === '::1';
        }

        // Главная функция анализа
        function analyzeHeaders() {
            const headerText = document.getElementById('headerInput').value.trim();
            
            if (!headerText) {
                alert('Пожалуйста, вставьте заголовки email для анализа');
                return;
            }

            // Показываем загрузку
            document.querySelector('.loading').style.display = 'block';
            document.getElementById('results').style.display = 'none';

            setTimeout(() => {
                try {
                    const headers = parseHeaders(headerText);
                    const path = analyzeReceivedHeaders(headers);
                    const spf = analyzeSPF(headers);
                    const dkim = analyzeDKIM(headers);
                    const dmarc = analyzeDMARC(headers);
                    const emailType = detectEmailType(headers, path);

                    const analysis = {
                        headers: headers,
                        path: path,
                        spf: spf,
                        dkim: dkim,
                        dmarc: dmarc,
                        emailType: emailType,
                        from: formatEmailAddress((headers['From'] || [''])[0]),
                        to: formatEmailAddress((headers['To'] || [''])[0]),
                        subject: decodeMimeHeader((headers['Subject'] || [''])[0]),
                        date: (headers['Date'] || [''])[0],
                        messageId: (headers['Message-ID'] || headers['Message-Id'] || [''])[0],
                        returnPath: (headers['Return-Path'] || [''])[0],
                        replyTo: formatEmailAddress((headers['Reply-To'] || ['-'])[0]),
                        deliveredTo: (headers['Delivered-To'] || ['-'])[0],
                        cc: formatEmailAddress((headers['CC'] || headers['Cc'] || ['-'])[0]),
                        bcc: formatEmailAddress((headers['BCC'] || headers['Bcc'] || ['-'])[0]),
                        xMailer: (headers['X-Mailer'] || headers['User-Agent'] || ['-'])[0],
                        originIP: path.length > 0 ? (path[0].fromIP || path[0].allIPs[0] || '-') : '-',
                        xOriginatingIP: (headers['X-Originating-IP'] || ['-'])[0],
                        clientIP: (headers['X-Client-IP'] || ['-'])[0]
                    };

                    currentAnalysis = analysis;

                    // Рассчитываем оценку риска
                    const riskAssessment = calculateRiskScore(analysis);
                    
                    // Отображаем результаты
                    displayResults(analysis, riskAssessment);

                    // Скрываем загрузку, показываем результаты
                    document.querySelector('.loading').style.display = 'none';
                    document.getElementById('results').style.display = 'block';
                } catch (error) {
                    console.error('Ошибка анализа:', error);
                    alert('Произошла ошибка при анализе заголовков. Проверьте формат данных.');
                    document.querySelector('.loading').style.display = 'none';
                }
            }, 500);
        }

        // Отображение результатов
        function displayResults(analysis, riskAssessment) {
            // Тип письма
            const emailTypeBadge = document.getElementById('emailTypeBadge');
            if (analysis.emailType === 'internal') {
                emailTypeBadge.className = 'email-type-badge email-internal';
                emailTypeBadge.textContent = '🏢 Внутреннее письмо';
            } else {
                emailTypeBadge.className = 'email-type-badge email-external';
                emailTypeBadge.textContent = '🌍 Внешнее письмо';
            }

            // Оценка риска
            const scoreElement = document.getElementById('riskScore');
            const labelElement = document.getElementById('riskLabel');
            
            scoreElement.textContent = riskAssessment.score;
            
            if (riskAssessment.score <= 25) {
                scoreElement.className = 'risk-value risk-low';
                labelElement.textContent = 'Низкий риск';
            } else if (riskAssessment.score <= 50) {
                scoreElement.className = 'risk-value risk-medium';
                labelElement.textContent = 'Средний риск';
            } else if (riskAssessment.score <= 75) {
                scoreElement.className = 'risk-value risk-high';
                labelElement.textContent = 'Высокий риск';
            } else {
                scoreElement.className = 'risk-value risk-critical';
                labelElement.textContent = 'Критический';
            }

            // Отображение предупреждений
            const alertsContainer = document.getElementById('alertsContainer');
            alertsContainer.innerHTML = '';
            riskAssessment.alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert-box alert-${alert.type}`;
                const icon = alert.type === 'danger' ? '⚠️' : 
                            alert.type === 'warning' ? '⚡' : 
                            alert.type === 'success' ? '✅' : 'ℹ️';
                alertDiv.innerHTML = `
                    <span>${icon}</span>
                    <span>${alert.message}</span>
                `;
                alertsContainer.appendChild(alertDiv);
            });

            // Обновление сводки
            document.getElementById('fromAddress').textContent = analysis.from || '-';
            document.getElementById('replyTo').textContent = analysis.replyTo || '-';
            document.getElementById('returnPath').textContent = analysis.returnPath || '-';
            document.getElementById('toAddress').textContent = analysis.to || '-';
            document.getElementById('deliveredTo').textContent = analysis.deliveredTo || '-';
            document.getElementById('ccAddress').textContent = analysis.cc || '-';
            document.getElementById('bccAddress').textContent = analysis.bcc || '-';
            document.getElementById('subject').textContent = analysis.subject || '-';
            document.getElementById('messageId').textContent = analysis.messageId || '-';
            document.getElementById('date').textContent = analysis.date || '-';
            document.getElementById('xMailer').textContent = analysis.xMailer || '-';
            document.getElementById('originIP').textContent = analysis.originIP || '-';
            document.getElementById('xOriginatingIP').textContent = analysis.xOriginatingIP || '-';
            document.getElementById('clientIP').textContent = analysis.clientIP || '-';

            // Индикаторы отправителя
            const senderIndicators = document.getElementById('senderIndicators');
            senderIndicators.innerHTML = '';
            
            if (analysis.emailType === 'internal') {
                senderIndicators.innerHTML += '<span class="indicator indicator-internal">Внутренний домен</span>';
            }
            
            if (analysis.from && analysis.from !== '-' && analysis.replyTo && analysis.replyTo !== '-') {
                const fromDomain = extractDomain(analysis.from);
                const replyDomain = extractDomain(analysis.replyTo);
                if (fromDomain !== replyDomain) {
                    senderIndicators.innerHTML += '<span class="indicator indicator-warning">Reply-To mismatch</span>';
                }
            }
            
            if (analysis.from && analysis.from !== '-' && analysis.returnPath && analysis.returnPath !== '-') {
                const fromDomain = extractDomain(analysis.from);
                const returnDomain = extractDomain(analysis.returnPath);
                if (fromDomain !== returnDomain) {
                    senderIndicators.innerHTML += '<span class="indicator indicator-suspicious">Domain mismatch</span>';
                }
            }

            // IP индикаторы
            const ipIndicators = document.getElementById('ipIndicators');
            ipIndicators.innerHTML = '';
            if (analysis.originIP && analysis.originIP !== '-') {
                if (isPrivateIP(analysis.originIP)) {
                    ipIndicators.innerHTML += '<span class="indicator indicator-safe">Private IP</span>';
                } else if (isLoopbackIP(analysis.originIP)) {
                    ipIndicators.innerHTML += '<span class="indicator indicator-safe">Loopback IP</span>';
                } else {
                    ipIndicators.innerHTML += '<span class="indicator indicator-warning">External IP</span>';
                }
            }

            // Отображение пути
            displayPath(analysis.path);

            // Отображение аутентификации
            displayAuthentication(analysis);

            // Отображение всех заголовков
            displayAllHeaders(analysis.headers);

            // Отображение raw заголовков
            document.getElementById('rawHeaders').textContent = document.getElementById('headerInput').value;
        }

        // Отображение пути доставки
        function displayPath(path) {
            const timeline = document.getElementById('pathTimeline');
            const visualization = document.getElementById('pathVisualization');
            
            timeline.innerHTML = '';
            visualization.innerHTML = '';

            if (path.length === 0) {
                timeline.innerHTML = '<p>Путь доставки не найден</p>';
                return;
            }

            path.forEach((hop, index) => {
                // Timeline
                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item';
                
                const ipInfo = hop.fromIP ? ` (${hop.fromIP})` : 
                              hop.allIPs.length > 0 ? ` (${hop.allIPs[0]})` : '';
                
                timelineItem.innerHTML = `
                    <div class="timeline-content">
                        <div class="timeline-server">Хоп ${hop.index}: ${hop.by}</div>
                        <div>От: ${hop.from}${ipInfo}</div>
                        ${hop.with !== 'unknown' ? `<div>Протокол: ${hop.with}</div>` : ''}
                        ${hop.id ? `<div>ID: ${hop.id}</div>` : ''}
                        ${hop.via ? `<div>Via: ${hop.via}</div>` : ''}
                        <div class="timeline-date">${hop.date}</div>
                    </div>
                `;
                timeline.appendChild(timelineItem);

                // Visualization
                if (index > 0) {
                    visualization.innerHTML += '<span class="path-arrow">→</span>';
                }
                const node = document.createElement('span');
                node.className = 'path-node';
                node.textContent = hop.by.split('.')[0];
                node.title = hop.raw;
                visualization.appendChild(node);
            });
        }

        // Отображение аутентификации
        function displayAuthentication(analysis) {
            // SPF
            const spfResults = document.getElementById('spfResults');
            if (analysis.emailType === 'internal') {
                spfResults.innerHTML = `
                    <div><span class="label">Status:</span> 
                        <span class="indicator spf-none">Не требуется</span>
                    </div>
                    <div><span class="label">Тип письма:</span> Внутреннее</div>
                    <div><span class="label">Details:</span> SPF проверка не требуется для внутренней почты</div>
                `;
            } else {
                const spfClass = analysis.spf.status === 'pass' ? 'spf-pass' : 
                                analysis.spf.status === 'fail' ? 'spf-fail' : 
                                analysis.spf.status === 'softfail' ? 'spf-softfail' : 
                                analysis.spf.status === 'neutral' ? 'spf-neutral' : 'spf-none';
                
                spfResults.innerHTML = `
                    <div><span class="label">Status:</span> 
                        <span class="indicator ${spfClass}">${analysis.spf.status.toUpperCase()}</span>
                    </div>
                    <div><span class="label">Domain:</span> ${analysis.spf.domain || '-'}</div>
                    <div><span class="label">IP:</span> ${analysis.spf.ip || '-'}</div>
                    <div><span class="label">Details:</span> ${analysis.spf.details || 'Нет дополнительной информации'}</div>
                `;
            }

            // DKIM
            const dkimResults = document.getElementById('dkimResults');
            if (analysis.emailType === 'internal') {
                dkimResults.innerHTML = `
                    <div><span class="label">Status:</span> 
                        <span class="indicator spf-none">Не требуется</span>
                    </div>
                    <div><span class="label">Тип письма:</span> Внутреннее</div>
                    <div><span class="label">Details:</span> DKIM проверка не требуется для внутренней почты</div>
                `;
            } else {
                const dkimClass = analysis.dkim.status === 'pass' ? 'dkim-pass' : 
                                 analysis.dkim.status === 'fail' ? 'dkim-fail' : 'spf-none';
                
                dkimResults.innerHTML = `
                    <div><span class="label">Status:</span> 
                        <span class="indicator ${dkimClass}">${analysis.dkim.status.toUpperCase()}</span>
                    </div>
                    <div><span class="label">Domain:</span> ${analysis.dkim.domain || '-'}</div>
                    <div><span class="label">Selector:</span> ${analysis.dkim.selector || '-'}</div>
                    <div><span class="label">Signature:</span> ${analysis.dkim.signature ? '✅ Present' : '❌ Missing'}</div>
                    <div><span class="label">Details:</span> ${analysis.dkim.details || 'Нет дополнительной информации'}</div>
                `;
            }

            // DMARC
            const dmarcResults = document.getElementById('dmarcResults');
            if (analysis.emailType === 'internal') {
                dmarcResults.innerHTML = `
                    <div><span class="label">Status:</span> 
                        <span class="indicator spf-none">Не требуется</span>
                    </div>
                    <div><span class="label">Тип письма:</span> Внутреннее</div>
                    <div><span class="label">Details:</span> DMARC проверка не требуется для внутренней почты</div>
                `;
            } else {
                const dmarcClass = analysis.dmarc.status === 'pass' ? 'dmarc-pass' : 
                                  analysis.dmarc.status === 'fail' ? 'dmarc-fail' : 'spf-none';
                
                dmarcResults.innerHTML = `
                    <div><span class="label">Status:</span> 
                        <span class="indicator ${dmarcClass}">${analysis.dmarc.status.toUpperCase()}</span>
                    </div>
                    <div><span class="label">Policy:</span> ${analysis.dmarc.policy || '-'}</div>
                    <div><span class="label">Domain:</span> ${analysis.dmarc.domain || '-'}</div>
                    <div><span class="label">Details:</span> ${analysis.dmarc.details || 'Нет дополнительной информации'}</div>
                `;
            }

            // Шифрование
            const encryptionResults = document.getElementById('encryptionResults');
            const hasTLS = analysis.path.some(hop => 
                hop.with && (hop.with.toLowerCase().includes('tls') || 
                            hop.with.toLowerCase().includes('ssl') ||
                            hop.raw.toLowerCase().includes('tls') ||
                            hop.raw.toLowerCase().includes('ssl')));
            
            const hasSTARTTLS = analysis.path.some(hop => 
                hop.raw.toLowerCase().includes('starttls') ||
                (hop.with && hop.with.toLowerCase().includes('esmtps')));
            
            encryptionResults.innerHTML = `
                <div><span class="label">TLS/SSL:</span> ${hasTLS ? '✅ Обнаружено' : '⚠️ Не обнаружено'}</div>
                <div><span class="label">STARTTLS:</span> ${hasSTARTTLS ? '✅ Обнаружено' : '⚠️ Не обнаружено'}</div>
                <div><span class="label">Уровень шифрования:</span> ${hasTLS ? 'Зашифровано при передаче' : 'Возможно не зашифровано'}</div>
                ${analysis.emailType === 'internal' ? '<div><span class="label">Примечание:</span> Внутренняя почта обычно передается по защищенным каналам</div>' : ''}
            `;
        }

        // Отображение всех заголовков
        function displayAllHeaders(headers) {
            const allHeaders = document.getElementById('allHeaders');
            allHeaders.innerHTML = '';
            
            const sortedKeys = Object.keys(headers).sort();
            
            // Определяем заголовки, которые нужно декодировать
            const headersToFormat = ['From', 'To', 'CC', 'Cc', 'BCC', 'Bcc', 'Reply-To'];
            const headersToDecode = ['Subject'];
            
            sortedKeys.forEach(key => {
                headers[key].forEach(value => {
                    const headerDiv = document.createElement('div');
                    headerDiv.style.marginBottom = '10px';
                    headerDiv.style.wordBreak = 'break-word';
                    
                    let displayValue = value;
                    
                    // Форматируем email адреса
                    if (headersToFormat.includes(key)) {
                        displayValue = formatEmailAddress(value);
                    } 
                    // Декодируем MIME заголовки
                    else if (headersToDecode.includes(key) || value.includes('=?')) {
                        displayValue = decodeMimeHeader(value);
                    }
                    
                    headerDiv.innerHTML = `<span class="label">${key}:</span> <span class="value">${displayValue}</span>`;
                    allHeaders.appendChild(headerDiv);
                });
            });
        }

        // Переключение вкладок
        function switchTab(tabName) {
            // Удаляем активный класс со всех вкладок
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Добавляем активный класс выбранной вкладке
            event.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        // Загрузка примера
        function loadExample() {
            const exampleHeader = `Delivered-To: victim@example.com
Received: by 2002:a05:6512:3b8f:b0:4f5:c2fc:748b with SMTP id v15csp2861234lfp;
        Thu, 15 Dec 2024 08:23:45 -0800 (PST)
X-Google-Smtp-Source: AGHT+IHxKjZB8RqL5NfMZXqY2c0qKLJmF+pXvRYN8H2wVBqCKCL8RTQb5xKz0R/lBGR2qOVn2kXu
X-Received: by 2002:a05:6402:35c8:b0:531:3a4f:8e60 with SMTP id z8-20020a05640235c800b005313a4f8e60mr11298062edc.39.1702659825341;
        Thu, 15 Dec 2024 08:23:45 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1702659825; cv=none;
        d=google.com; s=arc-20160816;
        b=KoC7IgAV9T1234567890ABCDEF==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=date:message-id:subject:to:from:dkim-signature;
        bh=abc123def456ghi789==;
        b=XYZ789abc123def456==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=fail header.i=@phishing-domain.com header.s=selector1 header.b=ABC123XYZ;
       spf=fail (google.com: domain of noreply@phishing-domain.com does not designate 192.0.2.123 as permitted sender) smtp.mailfrom=noreply@phishing-domain.com;
       dmarc=fail (p=QUARANTINE sp=QUARANTINE dis=QUARANTINE) header.from=trusted-bank.com
Return-Path: <noreply@phishing-domain.com>
Received: from mail.phishing-domain.com (mail.phishing-domain.com. [192.0.2.123])
        by mx.google.com with ESMTPS id x12-20020a056402358c00b00531f85c8ad9si3021009edc.597.2024.12.15.08.23.45
        for <victim@example.com>
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Thu, 15 Dec 2024 08:23:45 -0800 (PST)
Received-SPF: fail (google.com: domain of noreply@phishing-domain.com does not designate 192.0.2.123 as permitted sender) client-ip=192.0.2.123;
Authentication-Results: mx.google.com;
       dkim=fail header.i=@phishing-domain.com header.s=selector1 header.b=ABC123XYZ;
       spf=fail (google.com: domain of noreply@phishing-domain.com does not designate 192.0.2.123 as permitted sender) smtp.mailfrom=noreply@phishing-domain.com;
       dmarc=fail (p=QUARANTINE sp=QUARANTINE dis=QUARANTINE) header.from=trusted-bank.com
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=phishing-domain.com; s=selector1;
        h=from:to:subject:date:message-id;
        bh=abc123def456ghi789==;
        b=ABC123XYZ890abcdef==
Received: from localhost (unknown [10.0.0.1])
        by mail.phishing-domain.com (Postfix) with ESMTP id 4XyZ1234567890
        for <victim@example.com>; Thu, 15 Dec 2024 16:23:44 +0000 (UTC)
From: "Trusted Bank Security" <security@trusted-bank.com>
Reply-To: support@phishing-domain.com
To: victim@example.com
Subject: URGENT: Verify your account immediately
Message-ID: <1234567890.abcdef@phishing-domain.com>
Date: Thu, 15 Dec 2024 16:23:44 +0000
X-Mailer: Suspicious Mailer v1.0
X-Originating-IP: [192.0.2.123]
Content-Type: text/html; charset=UTF-8`;

            document.getElementById('headerInput').value = exampleHeader;
        }

        // Очистка
        function clearAll() {
            document.getElementById('headerInput').value = '';
            document.getElementById('results').style.display = 'none';
            currentAnalysis = null;
        }

        // Экспорт анализа
        function exportAnalysis() {
            if (!currentAnalysis) {
                alert('Нет данных для экспорта. Сначала выполните анализ.');
                return;
            }

            const report = {
                timestamp: new Date().toISOString(),
                email_type: currentAnalysis.emailType,
                summary: {
                    from: currentAnalysis.from,
                    to: currentAnalysis.to,
                    subject: currentAnalysis.subject,
                    date: currentAnalysis.date,
                    risk_score: document.getElementById('riskScore').textContent,
                    risk_level: document.getElementById('riskLabel').textContent
                },
                authentication: {
                    spf: currentAnalysis.spf,
                    dkim: currentAnalysis.dkim,
                    dmarc: currentAnalysis.dmarc
                },
                path: currentAnalysis.path,
                alerts: Array.from(document.querySelectorAll('.alert-box')).map(alert => 
                    alert.textContent.trim().replace(/^[⚠️⚡✅ℹ️]\s*/, '')
                ),
                raw_headers: document.getElementById('headerInput').value
            };

            const dataStr = JSON.stringify(report, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `email_analysis_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        // Горячие клавиши
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                analyzeHeaders();
            }
            if (e.ctrlKey && e.key === 'l') {
                clearAll();
            }
        });

        // Автоматический анализ при вставке через Ctrl+V
        document.getElementById('headerInput').addEventListener('paste', function(e) {
            setTimeout(() => {
                if (this.value.length > 100) {
                    // Автоматически запускаем анализ если вставлен большой текст
                    analyzeHeaders();
                }
            }, 100);
        });
    </script>
</body>
</html>